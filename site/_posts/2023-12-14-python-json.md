---
layout: post
title:  "python: json serialization"
---

<span class="hidden">Как на Python сериализовать простенький объект в JSON.</span>

## Мотивация

Сидишь, пишешь код на **Python**, думаешь: _"Сериализую-ка я простенький объект, с помощью модуля из стандартной библиотеки – `json`"_.

### Класс

```python
class Data:
    def __init__(self):
        self.id = ""
        self.name = ""
        self.amount = 0
```

### Данные

```python
data_item = Data()

data_item.id = "12345"
data_item.name = "Qwerty"
data_item.amount = 9000
```

### Сериализуем

```python
import json

item_json = json.dumps(data_item, indent=2)

print(item_json)
```

### Ожидание

```bash
{
  "id": "12345",
  "name": "Qwerty",
  "amount": 9000
}
```

### Реальность

```bash
Object of type Data is not JSON serializable
  File "/Users/user/my-project/run.py", line 5, in <module>
    item_json = json.dumps(data_item, indent=2)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: Object of type Data is not JSON serializable
```

Казалось бы, ну что тут сложного, и что тут могло пойти не так...

Ну вот, модуль `json`, который из стандартной библиотеки **Python** – просто не умеет сериализовать экземпляры классов, by design. Deal with it.

## Решение: `jsonpickle` – простое, но со сторонней зависимостью

### Как пользоваться `jsonpickle`

1. Устанавливаем `jsonpickle`:

   ```bash
   pip3 install jsonpickle
   ```

2. Сериализуем объект, вот таким образом:

   ```python
   import jsonpickle

   item_json = jsonpickle.encode(data_item, unpicklable=False, indent=2)
   ```

   Аргумент `unpicklable=False` здесь нужен для того, чтобы не сериализовались мета-данные о самом классе. По умолчанию – сериализуется вместе с ними. А нам, скорее всего, это не нужно.

### Достоинства `jsonpickle`

1. Сериализует объекты.
2. Сериализует также объекты внутри объекта.
3. Сериализует листы объектов.

### Недостатки `jsonpickle`

1. Нужно отдельно устанавливать.
2. При сериализации, нужно не забывать указывать дополнительный аргумент, чтобы JSON выглядел как обычно, без лишних деталей.

## Решение: стандартный модуль `json` – чуть сложнее, но без зависимостей

Вообще, [официальная документация](https://docs.python.org/3/library/json.html), на этот случай, предлагает унаследовать наш простенький объект от какого-то там `json.JSONEncoder`, и заоверрайдить какие-то там методы – да ну нафиг. Делать-то нам больше нечего...

### Как закостылить сериализацию с `json`

Прикол в том, что словари-то он сериализовывать умеет. И тут нам поможет волшебное слово `__dict__`, которое можно вызывать как атрибут у любого объекта:

```python
item_json = json.dumps(data_item.__dict__, indent=2)
```

Для нашего простенького объекта, результат получится точно такой же, как и с использованием `jsonpickle`

### Достоинства костыля с `json`

1. Легко запомнить.
2. Не нужно устанавливать сторонние зависимости.

### Недостатки костыля с `json`

1. Не умеет сериализовывать объекты внутри объекта.
2. Не сможет сериализовать даже лист объектов!

Хотя, для решения этих проблем есть простой (по принципу) хак, но достаточно многословный.

```python
# Конвертируем лист объектов в лист словарей:
data_list_serializable = [item.__dict__ for item in data_list]

# Сериализуем:
list_json = json.dumps(data_list_serializable, indent=2)
```

## Итог

Если мы хотим на **Python** сериализовать простой объект в JSON (**и** нам не лень ставить сторонние зависимости) – используем `jsonpickle`.

Если нам лень что-либо ставить (или есть какой-то специфичный ограничивающий юзкейс) – костылим сериализацию с `json` из стандартной библиотеки.
