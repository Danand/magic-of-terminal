---
layout: post
title:  "bash-alias-sync: recall, fzf"
---

<span class="hidden">"Элиас для вспоминания <strong>Bash</strong> команд".</span>

## Контекст

Помните такой принцип — **DRY**? Вот и я _не помню_.

А как вспомнить?

Ладно, этот пост вообще не об этом (принципе), в принципе. Но о запоминании и повторении — это точно.

Я забываю команды для терминала, в долго жму стрелочку вверх — и всё равно ничего не нахожу!

А если у меня есть только _нечёткие_ воспоминания о исполненной недавно команде?

Это продолжение постов про [`bash-alias-sync`](https://danand.github.io/magic-of-terminal/posts/bash-allias-sync-touch-p).<br />
И, да: ниже представлены функции (`function`), а не буквально элиасы (`alias`), потому, что мне так удобнее:

1. Функции можно сделать видимыми в других функциях и скриптах.
2. Многострочные функции, в отличие от элиасов:
   - гораздо легче писать (с подсветкой)
   - не нужно эскейпить

## Устанавливаем [**Command-line Fuzzy Finder (_aka_ FZF)**](https://github.com/junegunn/fzf)

Он понадобится, как раз, для _нечёткого_ поиска. Да и, вообще, для отрисовки выбора вхождения из истории.

```bash
sudo apt update && \
sudo apt install -y fzf
```

## Пишем функцию

```bash
function recall-fzf() {
  # Используем ключевое слово `builtin`, на случай,
  # если у нас заоверрайдена команда `history` (у меня так).

  builtin history -a # Аппендим историю из сессии в файл истории.
  builtin history -c # Чистим историю сессии.
  builtin history -r # Читаем историю из файла обратно в сессию.

  # Теперь у нас в сессии есть вся история.

  local entry # Объявляем локальную переменную,
  # чтобы она ни с чем не конфликтовала.

  entry="$( \
    builtin history -w "/dev/stdout" \      # Выводим историю из сессии в пайп.
    | uniq-unsorted \                       # Убираем дубликаты.
    | fzf \                                 # Запускаем интерактивный нечёткий поиск.
      --tac \                               # Читаем историю с конца.
      --header="Pick line from history:" \  # Задаём тайтл, чтобы было понятно, что делать.
      --layout="reverse" \                  # Рисуем выбор вхождения снизу от промпта, а не сверху.
      --no-sort \                           # Не сортируем вхождения по алфавиту.
      --height="33%" \                      # Выводим вхождения не во весь экран.
  )"

  if [ -z "${entry}" ]; then
    return 0 # Выходим, если ничего не выбрали.
  fi

  # Рисуем промпт и подставляем после него
  # выбранное вхождение для того,
  # чтобы его можно было отредактировать
  # перед выполнением:

  read \
    -er \
    -i "${entry}" \
    -p "${PS1@P}" \ # Вот так, кстати, форматируется вывод промпта!
    input

  eval "${input}" \                 # Выполняем через `eval`, чтобы какой-нибудь `xargs` не исполнил лишнего.
  && builtin history -s "${input}"  # Пишем в историю, в случае успешного выполнения.
}
```

Функция `uniq-unsorted` — не встроенная, она самописная. Пишем и её тоже:

```bash
function uniq-unsorted() {
  local index=0

  while read -r entry; do
    echo -e "$((index=index+1))\t${entry}"
  done \
  | sort \
    --uniq \
    -k 2 \
  | sort \
    -k 1 \
    -n \
  | cut \
    -f 2
}
```

## Используем

<video controls width="900" style="max-width: 100%;">
  <source src="{{ site.baseurl }}/assets/videos/recall-fzf.webm" type="video/webm">
  `recall-fzf` usage video was here.
</video>

## Вообще-то это велосипед

Как минимум, в **Gnome Terminal**, есть встроенная похожая штука, запускающаяся по нажатию сочетания клавиш **CTRL+R**, но она даже близко не работает так же интуитивно, как решение с использованием `fzf`

А ещё, там нельзя листать по найденным вхождениям.
